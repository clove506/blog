---
title: 【优护助手-合肥】合肥项目-锁系统
date: 2016-12-13 00:10:00
categories: 合肥
tags:
- 优护助手
---

## 摘要

 合肥子项目-锁系统

<!--more-->
## 定义

* 一致性：同一个数据在同一个时刻只有一个值。
* 锁：在并发情况下，用来保证多线程竞争共享资源时结果一致性的手段。
* 使用锁的原因：
    当共享数据存在竞争时，最简单的解决办法就是加锁。锁机制限制在同一时间只允许一个线程访问产生竞争的数据的临界区。在并发写操作场景下，如果不加锁，无法保证结果一致性。

## 锁的分类
公平锁、非公平锁、自旋锁、可重入锁、偏向锁、轻量级锁、重量级锁、读写锁、互斥锁等待、排他锁、分布式锁。

## 分布式锁的特性（目前使用分布式锁的原因）

基于分布式锁的解决方案，比如zookeeper，redis都是相较于持久化（如利用InnoDB行锁，或事务，或version乐观锁）方案提供了高可用性，并且支持丰富化的使用场景。

数据库锁：数据库访问率过高；单点故障
Redis分布式锁：性能强劲；HA；Redis存储数据特性（搜集并格式化用户关键性操作日志数据，通过日志信息快速定位问题，解决或修复bug，计算用户购买商品相关性来进行行为预测）

Redis的外围由一个键、值映射的字典构成。与其他非关系型数据库主要不同在于：Redis中值的类型不仅限于字符串，还支持如下抽象数据类型：

* 字符串列表
* 无序不重复的字符串集合
* 有序不重复的字符串集合
* 键、值都为字符串的哈希表

举例：
    在书店系统中，java8函数式编程 这本书库存只剩1的时候，为了保证A和B同时下单，而只能出现一个人下单成功，另外一个人显示无库存的情况，我们可以对下单时书的库存来加锁，而这个锁的key可以是下单的唯一标识， 来保证这个订单只能属于一个人，从而来控制在竞争共享资源时结果一致性。
                 
## 实现
    
原理：使用redis的setnx()、get()、getset()方法，用于分布式锁。
     setnx命令（SET if Not eXists） 语法： SETNX key value 功能： 当且仅当 key 不存在，将 key 的值设为 value ，并返回1；若给定的 key 已经存在，则 SETNX 不做任何动作，并返回0。
     get命令  语法：get key 功能：当key值存在时，返回key对应的value值。若给定的 key不存在，不做任何动作，并返回nil。
     getset命令 语法 getset(key，newValue) 该方法是原子的，对key设置newValue这个值，并且返回key原来的旧值。假设key原来是不存在的，那么多次执行这个命令，会出现下边的效果：
    1. getset(key, "value1")  返回nil   此时key的值会被设置为value1
    2. getset(key, "value2")  返回value1   此时key的值会被设置为value2
    3. 依次类推！

介绍完要使用的命令后，具体的使用步骤如下：
    1. setnx(lockkey, 当前时间+过期超时时间) ，如果返回1，则获取锁成功；如果返回0则没有获取到锁，转向2。
    2. get(lockkey)获取值oldExpireTime ，并将这个value值与当前的系统时间进行比较，如果小于当前系统时间，则认为这个锁已经超时，可以允许别的请求重新获取，转向3。
    3. 计算newExpireTime=当前时间+过期超时时间，然后getset(lockkey, newExpireTime) 会返回当前lockkey的值currentExpireTime。
    4. 判断currentExpireTime与oldExpireTime 是否相等，如果相等，说明当前getset设置成功，获取到了锁。如果不相等，说明这个锁又被别的请求获取走了，那么当前请求可以直接返回失败，或者继续重试。
    5. 在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和对于锁设置的超时时间，如果小于锁设置的超时时间，则直接执行delete释放锁；如果大于锁设置的超时时间，则不需要再对锁进行处理。

经调研：Redission、Jedits和Tail第三方框架都能实现redis分布式锁。
 Redission和Jedis的区别和使用情况。
### 涉及原则
在订单流转的生命周期中，所有涉及获取订单状态、付款退款的操作时，都需要加锁。

#### 需要考虑的问题
- 锁的时效设置。在订单系统中，避免单点故障造成死锁，影响其他客户端获取锁，但是也要保证一旦一个客户端持锁，在客户端可用时不会被其他客户端解锁。<br>
  解决方式：在一个客户端请求持锁时，设置一个失效时间，通过key的时间戳来判断是否需要强制解锁。
- 持锁期间的check，在关键节点检查锁的状态，避免单点故障造成死锁，影响其他客户端获取锁。<br>
  解决方式：设计成可重入锁。（一旦当前持锁客户端或进程出现异常，应该如何通过消息通知其他障造成死锁，影响其他客户端获取锁。<br>
- 减少获取锁的操作，尽量减少redis压力。


#### 实现思路
## 测试
模拟并发操作共享资源，测试资源边界值。如：
    测试模拟数据，以Order为例，测试时发起10000个线程，在lockkey为ORDER_ORDER_ID，ORDER为领域模型，ORDER_ID为ORDER的唯一标识符。（假设超时时间为10秒钟->100000ms）

key的组成：领域模型_id

 lockkey：ORDER_1231  lockvalue: 12503212000
 lockkey：ORDER_1231  lockvalue: 12503223000
 lockkey：ORDER_1231  lockvalue: 12503230000
 lockkey：ORDER_1231  lockvalue: 12503233000
 ......    
    
测试效果：
lock-Thread-91
======获得锁后进行相应的操作======
unlock-Thread-91
   
lock-Thread-90
======获得锁后进行相应的操作======
unlock-Thread-90
   
lock-Thread-87
======获得锁后进行相应的操作======
unlock-Thread-87
   
lock-Thread-64
======获得锁后进行相应的操作======
unlock-Thread-64
   
lock-Thread-63
======获得锁后进行相应的操作======
unlock-Thread-63
.......
       
        
## 运维、排查问题、修复问题
所有记录的日志格式：1-ORDER-222-1233211000-GET_ORDER_222(待优化)

1. 对于每一个并发访问共享资源的请求加入日志记录，形如：model-modelId-operateAt-threadName，例如：<br>
    ORDER-222-1233211000-Thread01（待优化）<br>
    ORDER-222-1233211001-Thread02<br>
    ORDER-222-1233211002-Thread03<br>
    ORDER-222-1233211003-Thread04<br>
    ORDER-222-1233211004-Thread05<br>
    ORDER-222-1233211005-Thread06<br>
    .......
    
2. 对于获取到锁的请求加入日志记录，形如model-modelId-operateAt-Lockkey，例如：

   ORDER-222-1233211000-GET_ORDER_222(待优化)


  ps 2.0优化：对于一些用户的关键性操作请求格式化并记录日志，将来用来用户行为预测。

        
    
## 计划、排期


### 排期

| 内容 | 时间点 |
| --- | --- |
| 功能开发 | 4人日 |
| 注解测试 | 2人日 |


##**FAQ**

**1. 在订单的生命周期中，要用到锁的周期节点。**

**2. 列举Service使用锁的场景。**

**3. 其他客户端或者线程请求锁失败之后该如何处理**

**4. 当前已持锁的线程重复获取锁该如何处理**



## 评审结果
**存在的问题**
1. Redission和Jedis的使用情况和两者的优劣？
    Redission是github上一个针对redis操作的开源框架，Jedis是Redis官方推出的java客户端。redisson实现了分布式和可扩展的java数据结构，支持的数据结构有：List, Set, Map, Queue, SortedSet,ConcureentMap, Lock, AtomicLong, CountDownLatch，并且是线程安全的，底层使用Netty 实现网络通信。和jedis相比，功能比较简单，不支持排序，事务，管道，分区等redis特性，可以认为是jedis的补充，不能替换jedis。
     使用情况：两者都是官方推荐的java客户端。
     最终，本次项目使用的是jedis。
2. 在redis中key的值？ 领域模型+该模型的唯一标识
3. redis分布式锁的具体实现，是采用Util还是AOP方式实现？ AOP方式实现
4. 订单系统中需要加锁的使用场景有哪些，如何使用？
        C端：
           服务详情-下单-提交订单操作
           提交订单-确认支付操作
           查看订单列表操作
           查看订单详情操作
           订单详情-取消订单操作
           退款操作
           订单评价提交操作
        B端：
           工作台订单管理查询操作
           订单中待接单列表查询操作
           订单中已接单列表查询操作
           接单操作
           完成订单操作
           查看订单详情操作
           同意退款操作
           拒绝退款
    使用方法：在模型的唯一标识符加上@lock或者@unlock注解。
    
   5.获取锁失败的其他线程该如何处理？
   在持锁线程设置的过期时间内，其他线程处于等待状态，当持锁线程持锁时间超过了过期时间，其他线程可以去竞争共享资源。
   6.如果当前线程已经获取锁，又重复获取锁该如何解决？
    在编写代码时避免再次获取已经持有的锁或者使用可重入锁。
   7.目前方式只能保证单一资源相同操作的分布式锁不能保证不同资源的不同操作的分布式锁，如何解决
   通过key的设置来解决保证对单一资源的并发访问的问题。
        
 
 
 
 
 
 
    
    
    


        
 




     

